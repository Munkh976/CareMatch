volunteers <- generate_volunteer_profiles(1000)
needs <- generate_needs()
skills <- generate_skills()
elderly_needs <- generate_elderly_needs(elderly, needs)
volunteer_skills <- generate_volunteer_skills(volunteers, skills)
matches <- generate_matches(elderly, volunteers, elderly_needs, volunteer_skills)
notifications <- generate_notifications(matches)
historical_matches <- generate_historical_matches()
clusters <- generate_clusters()
# --- Export Datasets to CSV ---
write.csv(elderly, "elderly.csv", row.names = FALSE)
write.csv(volunteers, "volunteers.csv", row.names = FALSE)
write.csv(needs, "needs.csv", row.names = FALSE)
write.csv(skills, "skills.csv", row.names = FALSE)
write.csv(elderly_needs, "elderly_needs.csv", row.names = FALSE)
write.csv(volunteer_skills, "volunteer_skills.csv", row.names = FALSE)
write.csv(matches, "matches.csv", row.names = FALSE)
write.csv(notifications, "notifications.csv", row.names = FALSE)
write.csv(historical_matches, "historical_matches.csv", row.names = FALSE)
write.csv(clusters, "clusters.csv", row.names = FALSE)
# Print confirmation
cat("All datasets have been created and exported to CSV files.\n")
# Print confirmation
cat("All datasets have been created and exported to CSV files.\n")
library(shiny)
# Set the working directory
setwd("C:/MS Data Science - WMU/CS5610-Advanced R/Projects/CareMatch/Project Code")
# Set the working directory
setwd("C:/MS Data Science - WMU/CS5610-Advanced R/Projects/CareMatch/Project Code/CareMatch")
# Load data from CSV
elderly_profiles <- read.csv("elderly.csv", stringsAsFactors = FALSE)
volunteer_profiles <- read.csv("volunteer.csv", stringsAsFactors = FALSE)
volunteer_profiles <- read.csv("volunteers.csv", stringsAsFactors = FALSE)
volunteer_profiles <- read.csv("volunteers.csv", stringsAsFactors = FALSE)
# Define UI
ui <- fluidPage(
titlePanel("Elderly Care Matching Chatbot"),
sidebarLayout(
sidebarPanel(
selectInput("user_type", "Are you an Elderly Person or a Volunteer?",
choices = c("Elderly", "Volunteer")),
textInput("last_name", "Your Last Name:"),
numericInput("user_age", "Your Age:", value = NA, min = 60, max = 120),
selectInput("gender", "Your Gender:", choices = c("Male", "Female")),
textInput("user_location", "Your Zip Code:"),
conditionalPanel(
condition = "input.user_type == 'Elderly'",
uiOutput("needs_choices"),
selectInput("preferred_time", "Preferred Time:",
choices = c("Morning", "Afternoon", "Evening")),
actionButton("submit_elderly", "Find Volunteers")
),
width = 4
),
mainPanel(
uiOutput("chat"),
width = 8
)
)
)
# Define Server
server <- function(input, output, session) {
chat_history <- reactiveVal(data.frame(User = character(), Message = character(), stringsAsFactors = FALSE))
observeEvent(input$last_name, {
matched_elder <- elderly_profiles[elderly_profiles$Last_Name == input$last_name &
elderly_profiles$Age == input$user_age &
elderly_profiles$Gender == input$gender &
elderly_profiles$Location == input$user_location, ]
if (nrow(matched_elder) > 0) {
updateCheckboxGroupInput(session, "user_needs", "Select Your Needs:",
choices = unique(unlist(strsplit(matched_elder$Needs, ", "))),
selected = unlist(strsplit(matched_elder$Needs, ", ")))
}
})
output$needs_choices <- renderUI({
checkboxGroupInput("user_needs", "Select Your Needs:",
choices = unique(unlist(strsplit(paste(elderly_profiles$Needs, collapse = ", "), ", "))))
})
observeEvent(input$submit_elderly, {
req(input$last_name, input$user_age, input$gender, input$user_location, input$user_needs, input$preferred_time)
isolate({
new_entry <- data.frame(
User = input$last_name,
Message = paste("Hello", input$last_name, "! You need help with:", paste(input$user_needs, collapse = ", "),
"at", input$preferred_time, "."),
stringsAsFactors = FALSE
)
chat_history(rbind(chat_history(), new_entry))
# Matching Volunteers
matched_volunteers <- volunteer_profiles[volunteer_profiles$Location == input$user_location &
grepl(paste(input$user_needs, collapse = "|"), volunteer_profiles$Skills) &
volunteer_profiles$Availability == input$preferred_time, ]
if (nrow(matched_volunteers) > 0) {
matches <- paste(matched_volunteers$Name, "- Skills:", matched_volunteers$Skills, "- Available:", matched_volunteers$Availability, collapse = "\n")
} else {
matches <- "No matching volunteers found."
}
chat_history(rbind(chat_history(), data.frame(User = "System", Message = matches, stringsAsFactors = FALSE)))
})
})
output$chat <- renderUI({
chat_content <- chat_history()
if (nrow(chat_content) == 0) {
h4("Welcome! Please enter your details to find assistance.")
} else {
do.call(tagList, lapply(1:nrow(chat_content), function(i) {
div(
strong(chat_content$User[i]), ": ", chat_content$Message[i],
style = "margin-bottom: 10px;"
)
}))
}
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(readr)
library(dplyr)
library(tidyr)
library(caret)
library(geosphere)
library(lubridate)
library(stringr)
# Improved Time Slot Overlap Function
# Helper function to parse time slots into comparable format
parse_slots <- function(slots) {
if (is.na(slots)) return(NA)
strsplit(slots, ", ")[[1]]
}
# Robust overlap detection
detect_overlap <- function(elderly_slots, volunteer_slots) {
e_slots <- parse_slots(elderly_slots)
v_slots <- parse_slots(volunteer_slots)
if (any(is.na(c(e_slots, v_slots)))) return(FALSE)
any(e_slots %in% v_slots)  # Exact match (for your current logic)
}
# Load data
datasets <- list("elderly", "volunteers", "needs", "skills",
"elderly_needs", "volunteer_skills", "matches",
"notifications", "historical_matches", "clusters")
for (dataset in datasets) {
assign(dataset, read.csv(paste0(dataset, ".csv")))
}
matches <- matches %>%
# Join with explicit column naming
left_join(
elderly_clean %>% select(elderly_id, elderly_lat = lat, elderly_lng = lng, preferred_time_slots),
by = "elderly_id"
) %>%
left_join(
volunteers_clean %>% select(volunteer_id, volunteer_lat = lat, volunteer_lng = lng, radius_willingness, availability),
by = "volunteer_id"
) %>%
# Calculate metrics
mutate(
location_distance = distHaversine(
cbind(elderly_lng, elderly_lat),
cbind(volunteer_lng, volunteer_lat)
) / 1000,
time_slot_overlapped = as.numeric(mapply(detect_overlap, preferred_time_slots, availability))
) %>%
# Apply both filters
filter(
time_slot_overlapped == 1,
location_distance <= radius_willingness
) %>%
# Prioritize best matches
arrange(location_distance)
# Improved Time Slot Overlap Function
# Helper function to parse time slots into comparable format
parse_slots <- function(slots) {
if (is.na(slots)) return(NA)
strsplit(slots, ", ")[[1]]
}
# Robust overlap detection
detect_overlap <- function(elderly_slots, volunteer_slots) {
e_slots <- parse_slots(elderly_slots)
v_slots <- parse_slots(volunteer_slots)
if (any(is.na(c(e_slots, v_slots)))) return(FALSE)
any(e_slots %in% v_slots)  # Exact match (for your current logic)
}
# Load data
datasets <- list("elderly", "volunteers", "needs", "skills",
"elderly_needs", "volunteer_skills", "matches",
"notifications", "historical_matches", "clusters")
for (dataset in datasets) {
assign(dataset, read.csv(paste0(dataset, ".csv")))
}
elderly_clean <- elderly %>% filter(!is.na(lat) & !is.na(lng))
volunteers_clean <- volunteers %>% filter(!is.na(lat) & !is.na(lng))
matches <- matches %>%
# Join with explicit column naming
left_join(
elderly_clean %>% select(elderly_id, elderly_lat = lat, elderly_lng = lng, preferred_time_slots),
by = "elderly_id"
) %>%
left_join(
volunteers_clean %>% select(volunteer_id, volunteer_lat = lat, volunteer_lng = lng, radius_willingness, availability),
by = "volunteer_id"
) %>%
# Calculate metrics
mutate(
location_distance = distHaversine(
cbind(elderly_lng, elderly_lat),
cbind(volunteer_lng, volunteer_lat)
) / 1000,
time_slot_overlapped = as.numeric(mapply(detect_overlap, preferred_time_slots, availability))
) %>%
# Apply both filters
filter(
time_slot_overlapped == 1,
location_distance <= radius_willingness
) %>%
# Prioritize best matches
arrange(location_distance)
#Handling Missing Data:
# we can either remove or impute missing values.
# Removing rows with missing values in any column
historical_matches_clean <- na.omit(historical_matches)
# Imputation using the mean or median
historical_matches$location_distance[is.na(historical_matches$location_distance)] <- mean(historical_matches$location_distance, na.rm = TRUE)
#Scaling and Normalizing Features for k-NN.
historical_matches$location_distance_scaled <- scale(historical_matches$location_distance)
#using one-hot encoding or label encoding for categorical variables.
historical_matches <- historical_matches %>%
mutate(accepted = as.factor(accepted))
set.seed(123)
train_index <- createDataPartition(historical_matches$accepted, p = 0.8, list = FALSE)
train_data <- historical_matches %>%
left_join(volunteers_clean %>% select(volunteer_id, radius_willingness), by = "volunteer_id") %>%
filter(!is.na(radius_willingness)) %>%
mutate(accepted = as.factor(accepted))
model <- glm(accepted ~ location_distance + time_slot_overlapped + radius_willingness,
data = train_data, family = binomial)
# Prediction
test_data <- historical_matches %>%
left_join(volunteers_clean %>% select(volunteer_id, radius_willingness), by = "volunteer_id") %>%
filter(!is.na(radius_willingness)) %>%
mutate(accepted = as.factor(accepted))
predictions <- predict(model, newdata = test_data, type = "response")
confusionMatrix(as.factor(ifelse(predictions > 0.5, 1, 0)), test_data$accepted)
# Match Probability Update
updated_matches <- matches %>%
mutate(
time_slot_overlapped = as.numeric(time_slot_overlapped),  # Ensuring binary 0/1 format
acceptance_probability = predict(model, newdata = matches, type = "response")
)
write.csv(updated_matches, "updated_matches.csv", row.names = FALSE)
# Notifications Filter
notifications <- updated_matches %>%
filter(acceptance_probability > 0.7) %>%
select(match_id, volunteer_id, elderly_id, match_score, acceptance_probability)
write.csv(notifications, "notifications_filtered.csv", row.names = FALSE)
library(ggplot2)
ggplot(data = historical_matches, aes(x = location_distance)) +
geom_histogram(bins = 30, fill = 'skyblue', color = 'black') +
labs(title = "Distribution of Location Distance", x = "Distance (km)", y = "Frequency")
ggplot(data = historical_matches, aes(x = accepted)) +
geom_bar(fill = 'lightgreen', color = 'black') +
labs(title = "Accepted vs Not Accepted", x = "Accepted", y = "Count")
ggplot(data = historical_matches, aes(x = accepted, y = location_distance)) +
geom_boxplot(fill = 'lightblue') +
labs(title = "Location Distance by Acceptance", x = "Accepted", y = "Distance (km)")
# install.packages("corrplot")
library(corrplot)
correlation_matrix <- cor(historical_matches %>% select(location_distance, time_slot_overlapped))
corrplot(correlation_matrix, method = "circle")
summary(historical_matches$location_distance)
mean(historical_matches$location_distance, na.rm = TRUE)
sd(historical_matches$location_distance, na.rm = TRUE)
t.test(location_distance ~ accepted, data = historical_matches)
cor.test(historical_matches$location_distance, historical_matches$time_slot_overlapped)
#install.packages("ggbiplot")
library(ggbiplot)
pca <- prcomp(historical_matches %>% select(location_distance, time_slot_overlapped), center = TRUE, scale. = TRUE)
ggbiplot(pca)
#
library(readr)
library(dplyr)
library(tidyr)
library(caret)
library(geosphere)
library(lubridate)
library(stringr)
# Improved Time Slot Overlap Function
detect_overlap <- function(time_slots1, time_slots2) {
if (is.na(time_slots1) || is.na(time_slots2)) return(FALSE)
slots1 <- unlist(strsplit(time_slots1, ", "))
slots2 <- unlist(strsplit(time_slots2, ", "))
return(any(slots1 %in% slots2))
}
# Load data
datasets <- list("elderly", "volunteers", "needs", "skills",
"elderly_needs", "volunteer_skills", "matches",
"notifications", "historical_matches", "clusters")
for (dataset in datasets) {
assign(dataset, read.csv(paste0(dataset, ".csv")))
}
# Clean data
elderly_clean <- elderly %>% filter(!is.na(lat) & !is.na(lng))
volunteers_clean <- volunteers %>% filter(!is.na(lat) & !is.na(lng))
# Match Calculation
matches <- matches %>%
left_join(elderly_clean %>% select(elderly_id, lat, lng, preferred_time_slots), by = "elderly_id") %>%
left_join(volunteers_clean %>% select(volunteer_id, lat, lng, radius_willingness, availability), by = "volunteer_id") %>%
rename(elderly_lat = lat.x, elderly_lng = lng.x, volunteer_lat = lat.y, volunteer_lng = lng.y) %>%
mutate(
location_distance = distHaversine(cbind(elderly_lng, elderly_lat),
cbind(volunteer_lng, volunteer_lat)) / 1000,
# Creating the time_slot_overlapped with binary (0/1)
time_slot_overlapped = as.numeric(mapply(detect_overlap, preferred_time_slots, availability))
) %>%
filter(time_slot_overlapped == 1)
#Handling Missing Data:
# we can either remove or impute missing values.
# Removing rows with missing values in any column
historical_matches_clean <- na.omit(historical_matches)
# Imputation using the mean or median
historical_matches$location_distance[is.na(historical_matches$location_distance)] <- mean(historical_matches$location_distance, na.rm = TRUE)
#Scaling and Normalizing Features for k-NN.
historical_matches$location_distance_scaled <- scale(historical_matches$location_distance)
#using one-hot encoding or label encoding for categorical variables.
historical_matches <- historical_matches %>%
mutate(accepted = as.factor(accepted))
set.seed(123)
train_index <- createDataPartition(historical_matches$accepted, p = 0.8, list = FALSE)
train_data <- historical_matches %>%
left_join(volunteers_clean %>% select(volunteer_id, radius_willingness), by = "volunteer_id") %>%
filter(!is.na(radius_willingness)) %>%
mutate(accepted = as.factor(accepted))
model <- glm(accepted ~ location_distance + time_slot_overlapped + radius_willingness,
data = train_data, family = binomial)
# Prediction
test_data <- historical_matches %>%
left_join(volunteers_clean %>% select(volunteer_id, radius_willingness), by = "volunteer_id") %>%
filter(!is.na(radius_willingness)) %>%
mutate(accepted = as.factor(accepted))
predictions <- predict(model, newdata = test_data, type = "response")
confusionMatrix(as.factor(ifelse(predictions > 0.5, 1, 0)), test_data$accepted)
# Match Probability Update
updated_matches <- matches %>%
mutate(
time_slot_overlapped = as.numeric(time_slot_overlapped),  # Ensuring binary 0/1 format
acceptance_probability = predict(model, newdata = matches, type = "response")
)
write.csv(updated_matches, "updated_matches.csv", row.names = FALSE)
# Notifications Filter
notifications <- updated_matches %>%
filter(acceptance_probability > 0.7) %>%
select(match_id, volunteer_id, elderly_id, match_score, acceptance_probability)
write.csv(notifications, "notifications_filtered.csv", row.names = FALSE)
library(ggplot2)
ggplot(historical_matches, aes(x = location_distance, fill = as.factor(accepted))) +
geom_histogram(bins = 30, alpha = 0.7, position = "identity") +
scale_fill_manual(values = c("red", "green"), labels = c("Not Accepted", "Accepted")) +
labs(title = "Impact of Distance on Match Acceptance",
x = "Distance (km)",
y = "Count") +
theme_minimal() +
theme(legend.title = element_blank(), text = element_text(size = 14))
ggplot(data = historical_matches, aes(x = location_distance)) +
geom_histogram(bins = 30, fill = 'lightgreen', color = 'black') +
labs(title = "Distribution of Location Distance", x = "Distance (km)", y = "Frequency") +
theme_minimal()
ggplot(data = historical_matches, aes(x = accepted)) +
geom_bar(fill = 'lightgreen', color = 'black') +
labs(title = "Accepted vs Not Accepted", x = "Accepted", y = "Count") +
theme_minimal()
ggplot(data = historical_matches, aes(x = as.factor(accepted), y = location_distance)) +
geom_boxplot(fill = 'lightgreen') +
labs(title = "Location Distance by Acceptance", x = "Accepted", y = "Distance (km)") +
theme_minimal()
# install.packages("corrplot")
library(corrplot)
library(ggcorrplot)
cor_matrix <- cor(historical_matches %>% select(location_distance, time_slot_overlapped, match_score))
ggcorrplot(cor_matrix, method = "circle", lab = TRUE)
install.packages("corrplot")
#
# install.packages("corrplot")
library(corrplot)
library(ggcorrplot)
# install.packages("corrplot")
install.packages("ggcorrplot")
library(corrplot)
library(ggcorrplot)
cor_matrix <- cor(historical_matches %>% select(location_distance, time_slot_overlapped, match_score))
library(ggcorrplot)
cor_matrix <- cor(historical_matches %>% select(location_distance, time_slot_overlapped, match_score))
#
library(readr)
library(dplyr)
library(tidyr)
library(caret)
library(geosphere)
library(lubridate)
library(stringr)
# Improved Time Slot Overlap Function
detect_overlap <- function(time_slots1, time_slots2) {
if (is.na(time_slots1) || is.na(time_slots2)) return(FALSE)
slots1 <- unlist(strsplit(time_slots1, ", "))
slots2 <- unlist(strsplit(time_slots2, ", "))
return(any(slots1 %in% slots2))
}
# Load data
datasets <- list("elderly", "volunteers", "needs", "skills",
"elderly_needs", "volunteer_skills", "matches",
"notifications", "historical_matches", "clusters")
for (dataset in datasets) {
assign(dataset, read.csv(paste0(dataset, ".csv")))
}
# Clean data
elderly_clean <- elderly %>% filter(!is.na(lat) & !is.na(lng))
volunteers_clean <- volunteers %>% filter(!is.na(lat) & !is.na(lng))
# Match Calculation
matches <- matches %>%
left_join(elderly_clean %>% select(elderly_id, lat, lng, preferred_time_slots), by = "elderly_id") %>%
left_join(volunteers_clean %>% select(volunteer_id, lat, lng, radius_willingness, availability), by = "volunteer_id") %>%
rename(elderly_lat = lat.x, elderly_lng = lng.x, volunteer_lat = lat.y, volunteer_lng = lng.y) %>%
mutate(
location_distance = distHaversine(cbind(elderly_lng, elderly_lat),
cbind(volunteer_lng, volunteer_lat)) / 1000,
# Creating the time_slot_overlapped with binary (0/1)
time_slot_overlapped = as.numeric(mapply(detect_overlap, preferred_time_slots, availability))
) %>%
filter(time_slot_overlapped == 1)
#Handling Missing Data:
# we can either remove or impute missing values.
# Removing rows with missing values in any column
historical_matches_clean <- na.omit(historical_matches)
# Imputation using the mean or median
historical_matches$location_distance[is.na(historical_matches$location_distance)] <- mean(historical_matches$location_distance, na.rm = TRUE)
#Scaling and Normalizing Features for k-NN.
historical_matches$location_distance_scaled <- scale(historical_matches$location_distance)
#using one-hot encoding or label encoding for categorical variables.
historical_matches <- historical_matches %>%
mutate(accepted = as.factor(accepted))
set.seed(123)
train_index <- createDataPartition(historical_matches$accepted, p = 0.8, list = FALSE)
train_data <- historical_matches %>%
left_join(volunteers_clean %>% select(volunteer_id, radius_willingness), by = "volunteer_id") %>%
filter(!is.na(radius_willingness)) %>%
mutate(accepted = as.factor(accepted))
model <- glm(accepted ~ location_distance + time_slot_overlapped + radius_willingness,
data = train_data, family = binomial)
# Prediction
test_data <- historical_matches %>%
left_join(volunteers_clean %>% select(volunteer_id, radius_willingness), by = "volunteer_id") %>%
filter(!is.na(radius_willingness)) %>%
mutate(accepted = as.factor(accepted))
predictions <- predict(model, newdata = test_data, type = "response")
confusionMatrix(as.factor(ifelse(predictions > 0.5, 1, 0)), test_data$accepted)
# Match Probability Update
updated_matches <- matches %>%
mutate(
time_slot_overlapped = as.numeric(time_slot_overlapped),  # Ensuring binary 0/1 format
acceptance_probability = predict(model, newdata = matches, type = "response")
)
write.csv(updated_matches, "updated_matches.csv", row.names = FALSE)
# Notifications Filter
notifications <- updated_matches %>%
filter(acceptance_probability > 0.7) %>%
select(match_id, volunteer_id, elderly_id, match_score, acceptance_probability)
write.csv(notifications, "notifications_filtered.csv", row.names = FALSE)
library(ggplot2)
ggplot(historical_matches, aes(x = location_distance, fill = as.factor(accepted))) +
geom_histogram(bins = 30, alpha = 0.7, position = "identity") +
scale_fill_manual(values = c("red", "green"), labels = c("Not Accepted", "Accepted")) +
labs(title = "Impact of Distance on Match Acceptance",
x = "Distance (km)",
y = "Count") +
theme_minimal() +
theme(legend.title = element_blank(), text = element_text(size = 14))
ggplot(data = historical_matches, aes(x = location_distance)) +
geom_histogram(bins = 30, fill = 'lightgreen', color = 'black') +
labs(title = "Distribution of Location Distance", x = "Distance (km)", y = "Frequency") +
theme_minimal()
ggplot(data = historical_matches, aes(x = accepted)) +
geom_bar(fill = 'lightgreen', color = 'black') +
labs(title = "Accepted vs Not Accepted", x = "Accepted", y = "Count") +
theme_minimal()
ggplot(data = historical_matches, aes(x = as.factor(accepted), y = location_distance)) +
geom_boxplot(fill = 'lightgreen') +
labs(title = "Location Distance by Acceptance", x = "Accepted", y = "Distance (km)") +
theme_minimal()
# install.packages("corrplot")
install.packages("ggcorrplot")
library(corrplot)
library(ggcorrplot)
cor_matrix <- cor(historical_matches %>% select(location_distance, time_slot_overlapped, match_score))
ggcorrplot(cor_matrix, method = "circle", lab = TRUE)
summary(historical_matches$location_distance)
mean(historical_matches$location_distance, na.rm = TRUE)
sd(historical_matches$location_distance, na.rm = TRUE)
t.test(location_distance ~ accepted, data = historical_matches)
cor.test(historical_matches$location_distance, historical_matches$time_slot_overlapped)
#install.packages("ggbiplot")
library(ggbiplot)
pca <- prcomp(historical_matches %>% select(location_distance, time_slot_overlapped), center = TRUE, scale. = TRUE)
ggbiplot(pca)
cor.test(historical_matches$location_distance, historical_matches$time_slot_overlapped)
#install.packages("ggbiplot")
library(ggbiplot)
pca <- prcomp(historical_matches %>% select(location_distance, time_slot_overlapped), center = TRUE, scale. = TRUE)
ggbiplot(pca)
#install.packages("ggbiplot")
library(ggbiplot)
pca <- prcomp(historical_matches %>% select(location_distance, time_slot_overlapped), center = TRUE, scale. = TRUE)
ggbiplot(pca)
---
title: "Ex8"
```{r setup, include=FALSE}
